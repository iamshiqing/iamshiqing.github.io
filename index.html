<!DOCTYPE html>
<html>
<head>
<title>ACM模板</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="centeracm%E6%A8%A1%E6%9D%BFcenter---omit-in-toc"><center>ACM模板</center><!-- omit in toc --></h1>
<ul>
<li><a href="#1-%E5%B8%B8%E7%94%A8%E6%9D%82%E9%A1%B9">1. 常用杂项</a>
<ul>
<li><a href="#11-%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96">1.1. 读入输出优化</a>
<ul>
<li><a href="#111-%E8%A7%A3%E9%99%A4%E6%B5%81%E5%90%8C%E6%AD%A5">1.1.1. 解除流同步</a></li>
<li><a href="#112-%E5%BF%AB%E8%AF%BB">1.1.2. 快读</a></li>
<li><a href="#113-%E5%BF%AB%E5%86%99">1.1.3. 快写</a></li>
</ul>
</li>
<li><a href="#12-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">1.2. 文件操作</a></li>
</ul>
</li>
<li><a href="#2-%E6%8E%92%E5%BA%8F">2. 排序</a>
<ul>
<li><a href="#21-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%A8%B3%E5%AE%9A">2.1. 快速排序（不稳定）</a></li>
<li><a href="#22-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%AF%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9">2.2. 归并排序（可求逆序对）</a></li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3. 数据结构</a>
<ul>
<li><a href="#31-%E5%90%91%E9%87%8F">3.1. 向量</a></li>
<li><a href="#32-%E6%A0%88">3.2. 栈</a></li>
<li><a href="#33-%E9%98%9F%E5%88%97">3.3. 队列</a></li>
<li><a href="#34-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">3.4. 双端队列</a></li>
<li><a href="#35-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">3.5. 优先队列</a></li>
<li><a href="#36-%E5%B9%B6%E6%9F%A5%E9%9B%86">3.6. 并查集</a></li>
<li><a href="#37-st%E8%A1%A8">3.7. ST表</a></li>
<li><a href="#38-%E7%BA%BF%E6%AE%B5%E6%A0%91">3.8. 线段树</a></li>
</ul>
</li>
<li><a href="#4-%E5%9B%BE%E8%AE%BA">4. 图论</a>
<ul>
<li><a href="#41-%E6%9C%80%E7%9F%AD%E8%B7%AF">4.1. 最短路</a>
<ul>
<li><a href="#411-floyd%E5%A4%9A%E6%BA%90--%E7%BB%8F%E5%85%B8%E8%8C%83%E5%9B%B4n500">4.1.1. floyd（多源）--经典范围n=500</a></li>
<li><a href="#412-dijkstra%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88%E5%8D%95%E6%BA%90">4.1.2. Dijkstra堆优化版（单源）</a></li>
<li><a href="#413-spfa%E5%8D%95%E6%BA%90--%E8%B4%9F%E6%9D%83%E5%9B%BE">4.1.3. SPFA（单源）--负权图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E6%95%B0%E8%AE%BA">5. 数论</a>
<ul>
<li><a href="#51-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">5.1. 最大公约数</a></li>
<li><a href="#52-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">5.2. 最小公倍数</a></li>
<li><a href="#53-%E5%BF%AB%E9%80%9F%E5%B9%82">5.3. 快速幂</a>
<ul>
<li><a href="#531-%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">5.3.1. 第一种实现方法</a></li>
<li><a href="#532-%E7%AC%AC%E4%BA%8C%E9%92%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">5.3.2. 第二钟实现方法</a></li>
</ul>
</li>
<li><a href="#54-%E9%80%86%E5%85%83">5.4. 逆元</a>
<ul>
<li><a href="#541-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">5.4.1. 费马小定理</a></li>
</ul>
</li>
<li><a href="#55-%E7%B4%A0%E6%95%B0%E7%AD%9B">5.5. 素数筛</a></li>
</ul>
</li>
<li><a href="#6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">6. 动态规划</a>
<ul>
<li><a href="#61-01%E8%83%8C%E5%8C%85">6.1. 01背包</a></li>
<li><a href="#62-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">6.2. 完全背包</a></li>
</ul>
</li>
<li><a href="#7-%E5%AD%97%E7%AC%A6%E4%B8%B2">7. 字符串</a></li>
<li><a href="#8-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95">8. 计算几何</a></li>
</ul>
<h2 id="1-%E5%B8%B8%E7%94%A8%E6%9D%82%E9%A1%B9">1. 常用杂项</h2>
<h3 id="11-%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96">1.1. 读入输出优化</h3>
<h4 id="111-%E8%A7%A3%E9%99%A4%E6%B5%81%E5%90%8C%E6%AD%A5">1.1.1. 解除流同步</h4>
<pre class="hljs"><code><div>ios::sync_with_stdio(<span class="hljs-literal">false</span>);
<span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);
<span class="hljs-built_in">cout</span>.tie(<span class="hljs-number">0</span>);
</div></code></pre>
<h4 id="112-%E5%BF%AB%E8%AF%BB">1.1.2. 快读</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">char</span> ch=getchar();
    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch)){
        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'-'</span>)
            f=<span class="hljs-number">-1</span>;
        ch=getchar();
    }
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch)){
        x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;
        ch=getchar();
    }
    <span class="hljs-keyword">return</span> x*f;
}
</div></code></pre>
<h4 id="113-%E5%BF%AB%E5%86%99">1.1.3. 快写</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sta[<span class="hljs-number">35</span>];
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>){
        x=-x;
        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>);
    }

    <span class="hljs-keyword">do</span>{
        sta[top++]=x%<span class="hljs-number">10</span>;
        x/=<span class="hljs-number">10</span>;
    }<span class="hljs-keyword">while</span>(x);
    <span class="hljs-keyword">while</span>(top) 
        <span class="hljs-built_in">putchar</span>(sta[--top]+<span class="hljs-string">'0'</span>); 
}
</div></code></pre>
<h3 id="12-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">1.2. 文件操作</h3>
<pre class="hljs"><code><div><span class="hljs-comment">//重定向后printf/scanf/cin/cout等函数正常使用</span>
freopen(<span class="hljs-string">"data.in"</span>,<span class="hljs-string">"r"</span>,<span class="hljs-built_in">stdin</span>);
freopen(<span class="hljs-string">"ans.out"</span>,<span class="hljs-string">"w"</span>,<span class="hljs-built_in">stdout</span>);

<span class="hljs-comment">//关闭标准输入/输出流</span>
fclose(<span class="hljs-built_in">stdin</span>);
fclose(<span class="hljs-built_in">stdout</span>);
</div></code></pre>
<h2 id="2-%E6%8E%92%E5%BA%8F">2. 排序</h2>
<h3 id="21-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%A8%B3%E5%AE%9A">2.1. 快速排序（不稳定）</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>{
    <span class="hljs-keyword">if</span>(r&lt;=l)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">int</span> flag=l;<span class="hljs-comment">//哨兵节点</span>
    <span class="hljs-keyword">int</span> ll=l,rr=r;
    <span class="hljs-keyword">while</span>(ll&lt;rr){
        <span class="hljs-comment">//两个循环顺序不能变，确保rr==ll时a[ll]&lt;=a[flag]</span>
        <span class="hljs-keyword">for</span>(;rr&gt;ll;rr--)
            <span class="hljs-keyword">if</span>(a[rr]&lt;a[flag]) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">for</span>(;ll&lt;rr;ll++)
            <span class="hljs-keyword">if</span>(a[ll]&gt;a[flag]) <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">if</span>(a[ll]&gt;a[flag]&amp;&amp;a[rr]&lt;a[flag])
            swap(a[ll],a[rr]);
    }
    swap(a[flag],a[ll]);
    qsort(l,ll<span class="hljs-number">-1</span>);
    qsort(ll+<span class="hljs-number">1</span>,r);
}
</div></code></pre>
<h3 id="22-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%AF%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9">2.2. 归并排序（可求逆序对）</h3>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a;
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//逆序对数</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>{
    <span class="hljs-keyword">if</span>(r&lt;=l)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;
    merge_sort(l,mid);
    merge_sort(mid+<span class="hljs-number">1</span>,r);
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;temp;
    <span class="hljs-keyword">int</span> ll=l,rr=mid+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(!(ll==mid+<span class="hljs-number">1</span>&amp;&amp;rr==r+<span class="hljs-number">1</span>)){
        <span class="hljs-keyword">if</span>(ll==mid+<span class="hljs-number">1</span>||(rr&lt;r+<span class="hljs-number">1</span>&amp;&amp;a[rr]&lt;a[ll])){
            temp.push_back(a[rr]);
            ans+=mid+<span class="hljs-number">1</span>-ll;<span class="hljs-comment">//求逆序对</span>
            rr++;
        }<span class="hljs-keyword">else</span>{
            temp.push_back(a[ll]);
            ll++;
        }
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++){
        a[l]=temp[i];
        l++;
    }
}
</div></code></pre>
<h2 id="3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3. 数据结构</h2>
<h3 id="31-%E5%90%91%E9%87%8F">3.1. 向量</h3>
<pre class="hljs"><code><div><span class="hljs-built_in">vector</span>&lt;T&gt;a;
a.assign();<span class="hljs-comment">//对向量中的元素赋值 </span>
a.front();<span class="hljs-comment">//返回第一个元素 </span>
a.back();<span class="hljs-comment">//返回最末一个元素 </span>
a.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//返回第一个元素的迭代器 </span>
a.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//返回最末元素下一个位置的迭代器</span>
a.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清空所有元素 </span>
a.empty();<span class="hljs-comment">//为空时返回真 </span>
a.erase();<span class="hljs-comment">//删除指定元素 </span>
a.insert();<span class="hljs-comment">//插入元素  </span>
a.pop_back();<span class="hljs-comment">//移除最后一个元素 </span>
a.push_back();<span class="hljs-comment">//在最后添加一个元素 </span>
a.rbegin();<span class="hljs-comment">//返回尾部的逆迭代器 </span>
a.rend();<span class="hljs-comment">//返回起始的逆迭代器 </span>
a.resize();<span class="hljs-comment">//改变元素数量 </span>
a.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回元素数量 </span>
a.swap();<span class="hljs-comment">//交换两个向量</span>
</div></code></pre>
<h3 id="32-%E6%A0%88">3.2. 栈</h3>
<pre class="hljs"><code><div><span class="hljs-built_in">stack</span>&lt;T&gt;a;
a.push();<span class="hljs-comment">//入栈</span>
a.pop();<span class="hljs-comment">//出栈</span>
a.top();<span class="hljs-comment">//返回栈顶元素</span>
a.empty();<span class="hljs-comment">//栈为空返回真</span>
a.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回栈内元素数量</span>
</div></code></pre>
<h3 id="33-%E9%98%9F%E5%88%97">3.3. 队列</h3>
<pre class="hljs"><code><div><span class="hljs-built_in">queue</span>&lt;T&gt;q;
q.push();<span class="hljs-comment">//入队</span>
q.pop();<span class="hljs-comment">//出队</span>
q.front();<span class="hljs-comment">//返回队首元素</span>
q.back();<span class="hljs-comment">//返回队尾元素</span>
q.empty();<span class="hljs-comment">//队为空返回真</span>
q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回队内元素数量</span>
</div></code></pre>
<h3 id="34-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">3.4. 双端队列</h3>
<pre class="hljs"><code><div><span class="hljs-built_in">deque</span>&lt;T&gt;a; 
a.assign();<span class="hljs-comment">//赋值</span>
a.at();<span class="hljs-comment">//返回指定的元素 </span>
a.front();<span class="hljs-comment">//返回首元素 </span>
a.back();<span class="hljs-comment">//返回尾元素 </span>
a.<span class="hljs-built_in">begin</span>();<span class="hljs-comment">//返回指向第一个元素的迭代器 </span>
a.<span class="hljs-built_in">end</span>();<span class="hljs-comment">//返回指向尾部的迭代器</span>
a.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//删除所有元素 </span>
a.empty();<span class="hljs-comment">//为空返回真  </span>
a.erase();<span class="hljs-comment">//删除一个元素  </span>
a.insert();<span class="hljs-comment">//插入一个元素</span>
a.pop_front();<span class="hljs-comment">//删除头部的元素 </span>
a.pop_back();<span class="hljs-comment">//删除尾部的元素</span>
a.push_front();<span class="hljs-comment">//在头部加入一个元素 </span>
a.push_back();<span class="hljs-comment">//在尾部加入一个元素 </span>
a.rend();<span class="hljs-comment">//返回指向头部的逆向迭代器  </span>
a.rbegin();<span class="hljs-comment">//返回指向尾部的逆向迭代器 </span>
a.resize();<span class="hljs-comment">//改变大小 </span>
a.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回元素个数 </span>
a.swap();<span class="hljs-comment">//和另一个双端队列交换元素 </span>
</div></code></pre>
<h3 id="35-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">3.5. 优先队列</h3>
<pre class="hljs"><code><div>priority_queue&lt;T&gt;q;<span class="hljs-comment">//降序,即top()为最大值</span>
priority_queue&lt;T,<span class="hljs-built_in">vector</span>&lt;T&gt;,greater&lt;T&gt; &gt;q;<span class="hljs-comment">//升序,即top()为最小值</span>
q.top();<span class="hljs-comment">//返回优先级最高的元素</span>
q.push();<span class="hljs-comment">//加入一个元素</span>
q.pop();<span class="hljs-comment">//删除第一个元素</span>
q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回元素个数 </span>
q.empty();<span class="hljs-comment">//为空返回真 </span>
</div></code></pre>
<h3 id="36-%E5%B9%B6%E6%9F%A5%E9%9B%86">3.6. 并查集</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">100000</span>;
<span class="hljs-keyword">int</span> root[MAX];<span class="hljs-comment">//存每个点的根节点</span>
<span class="hljs-keyword">int</span> tall[MAX];<span class="hljs-comment">//存每个节点的高，优化合并</span>
<span class="hljs-comment">//初始化根节点为自己，高为0</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX;i++)
        root[i]=i,tall[i]=<span class="hljs-number">0</span>;
}
<span class="hljs-comment">//递归查找根节点，并更新</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
    <span class="hljs-keyword">if</span>(n==root[n])
        <span class="hljs-keyword">return</span> n;
    <span class="hljs-keyword">else</span> 
        <span class="hljs-keyword">return</span> root[n]=<span class="hljs-built_in">find</span>(root[n]);
}
<span class="hljs-comment">//判断x,y是否在同一个集合</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">issame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);
} 
<span class="hljs-comment">//合并x，y两个集合</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>{
    x=<span class="hljs-built_in">find</span>(x);
    y=<span class="hljs-built_in">find</span>(y);
    <span class="hljs-keyword">if</span>(x==y)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tall[x]&lt;tall[y])
        root[y]=x;
    <span class="hljs-keyword">else</span>{
        root[x]=y;
        <span class="hljs-keyword">if</span>(tall[x]==tall[y])
            tall[x]++;
    }
}
</div></code></pre>
<h3 id="37-st%E8%A1%A8">3.7. ST表</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">100000</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p=<span class="hljs-number">20</span>;<span class="hljs-comment">//维护的最大区间，确保2*pow(2,p-1)&gt;=数据规模</span>
<span class="hljs-keyword">int</span> a[MAX][p+<span class="hljs-number">1</span>];<span class="hljs-comment">//存ST表,从下标1开始存</span>
<span class="hljs-keyword">int</span> pre[p+<span class="hljs-number">1</span>];
<span class="hljs-comment">//预处理pre,并对读入的数据进行建表</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{
    pre[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++)
        pre[i]=pre[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=p;i++){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j+pre[i]<span class="hljs-number">-1</span>&lt;=n;j++)
            a[j][i]=<span class="hljs-built_in">max</span>(a[j][i<span class="hljs-number">-1</span>],a[j+pre[i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]);<span class="hljs-comment">//维护从j开始长度为2^i区间的最大值</span>
    }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>{
    <span class="hljs-keyword">int</span> len=log2(r-l+<span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a[l][len],a[r-pre[len]+<span class="hljs-number">1</span>][len]);
}
</div></code></pre>
<h3 id="38-%E7%BA%BF%E6%AE%B5%E6%A0%91">3.8. 线段树</h3>
<pre class="hljs"><code><div><span class="hljs-comment">//线段树维护区间最大最小值  first为最大值在a数组中下标  second为最小值在a数组中下标 modify直接修改a数组</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">300001</span>;
<span class="hljs-keyword">int</span> a[MAX];<span class="hljs-comment">//原数组</span>
P tree[<span class="hljs-number">4</span>*MAX];<span class="hljs-comment">//线段树</span>
<span class="hljs-comment">//建树</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>{
    <span class="hljs-keyword">if</span>(l==r){
        tree[x]={l,l};
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;
    build(x*<span class="hljs-number">2</span>,l,mid);
    build(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);
    <span class="hljs-keyword">if</span>(a[tree[x*<span class="hljs-number">2</span>].first]&lt;a[tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].first]){
        tree[x].first=tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].first;
    }<span class="hljs-keyword">else</span>{
        tree[x].first=tree[x*<span class="hljs-number">2</span>].first;
    }
    <span class="hljs-keyword">if</span>(a[tree[x*<span class="hljs-number">2</span>].second]&lt;=a[tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].second]){
        tree[x].second=tree[x*<span class="hljs-number">2</span>].second;
    }<span class="hljs-keyword">else</span>{
        tree[x].second=tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].second;
    }
    <span class="hljs-keyword">return</span>;
}
<span class="hljs-comment">//单点修改，并更新区间最值</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> k)</span></span>{
    <span class="hljs-keyword">if</span>(l==r){
        a[l]+=k;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span>(p&lt;=mid){
        modify(x*<span class="hljs-number">2</span>,l,mid,p,k);
    }<span class="hljs-keyword">else</span>{
        modify(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,p,k);
    }
    <span class="hljs-keyword">if</span>(a[tree[x*<span class="hljs-number">2</span>].first]&lt;a[tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].first]){
        tree[x].first=tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].first;
    }<span class="hljs-keyword">else</span>{
        tree[x].first=tree[x*<span class="hljs-number">2</span>].first;
    }
    <span class="hljs-keyword">if</span>(a[tree[x*<span class="hljs-number">2</span>].second]&lt;=a[tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].second]){
        tree[x].second=tree[x*<span class="hljs-number">2</span>].second;
    }<span class="hljs-keyword">else</span>{
        tree[x].second=tree[x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].second;
    }
    <span class="hljs-keyword">return</span>;
}
<span class="hljs-comment">//区间查询</span>
<span class="hljs-function">P <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> x)</span></span>{
    <span class="hljs-keyword">if</span>(l==s&amp;&amp;r==t){
        <span class="hljs-keyword">return</span> tree[x];
    }
    <span class="hljs-keyword">int</span> mid=(s+t)/<span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span>(r&lt;=mid){
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(l,r,s,mid,x*<span class="hljs-number">2</span>);
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&gt;mid){
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(l,r,mid+<span class="hljs-number">1</span>,t,x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);
    }<span class="hljs-keyword">else</span>{
        P temp1=<span class="hljs-built_in">get</span>(l,mid,s,mid,x*<span class="hljs-number">2</span>);
        P temp2=<span class="hljs-built_in">get</span>(mid+<span class="hljs-number">1</span>,r,mid+<span class="hljs-number">1</span>,t,x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);
        P ans;
        <span class="hljs-keyword">if</span>(a[temp1.first]&lt;a[temp2.first]){
            ans.first=temp2.first;
        }<span class="hljs-keyword">else</span>{
            ans.first=temp1.first;
        }
        <span class="hljs-keyword">if</span>(a[temp1.second]&lt;=a[temp2.second]){
            ans.second=temp1.second;
        }<span class="hljs-keyword">else</span>{
            ans.second=temp2.second;
        }
        <span class="hljs-keyword">return</span> ans;
    }

}
</div></code></pre>
<h2 id="4-%E5%9B%BE%E8%AE%BA">4. 图论</h2>
<h3 id="41-%E6%9C%80%E7%9F%AD%E8%B7%AF">4.1. 最短路</h3>
<h4 id="411-floyd%E5%A4%9A%E6%BA%90--%E7%BB%8F%E5%85%B8%E8%8C%83%E5%9B%B4n500">4.1.1. floyd（多源）--经典范围n=500</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long </span>
<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n个点，m条边</span>
    <span class="hljs-keyword">int</span> inf=INT_MAX;<span class="hljs-comment">//未开long long 使用INT_MAX 可能INT_MAX+INT_MAX溢出导致错误</span>
    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;
    <span class="hljs-keyword">int</span> dp[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];
    <span class="hljs-built_in">fill</span>(dp[<span class="hljs-number">0</span>],dp[<span class="hljs-number">0</span>]+(n+<span class="hljs-number">1</span>)*(n+<span class="hljs-number">1</span>),inf);<span class="hljs-comment">//初始化为inf,即两个点之间不连接</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
        dp[i][i]=<span class="hljs-number">0</span>;<span class="hljs-comment">//i-&gt;i距离为零</span>
    }
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++){
        <span class="hljs-keyword">int</span> u,v,w;
        <span class="hljs-built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;<span class="hljs-comment">//u-&gt;v 长为w</span>
        dp[u][v]=<span class="hljs-built_in">min</span>(dp[u][v],w);
        dp[v][u]=<span class="hljs-built_in">min</span>(dp[v][u],w);<span class="hljs-comment">//无向图</span>
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
                dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[i][k]+dp[k][j]);<span class="hljs-comment">//i-&gt;j,i-&gt;k-&gt;j</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="412-dijkstra%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88%E5%8D%95%E6%BA%90">4.1.2. Dijkstra堆优化版（单源）</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>{</span>
    <span class="hljs-keyword">int</span> to,val; <span class="hljs-comment">//to为这条边的终点，val为这条边的权</span>
};
<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,m,s;<span class="hljs-comment">//n个点，m条边，s起始点</span>
    <span class="hljs-keyword">int</span> inf=INT_MAX;<span class="hljs-comment">//未开long long 使用INT_MAX 可能INT_MAX+INT_MAX溢出导致错误</span>
    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    <span class="hljs-built_in">vector</span>&lt;edge&gt;a[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//存图</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++){
        <span class="hljs-keyword">int</span> u,v,w;<span class="hljs-comment">//u-&gt;v 边权为w</span>
        <span class="hljs-built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        a[u].push_back({v,w});
        a[v].push_back({u,w});<span class="hljs-comment">//无向图</span>
    }
    <span class="hljs-keyword">int</span> dp[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//s至每个点的距离</span>
    <span class="hljs-built_in">fill</span>(dp,dp+n+<span class="hljs-number">1</span>,inf);<span class="hljs-comment">//初始s与所有点不连通</span>
    dp[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//s至s距离为0</span>
    priority_queue&lt;P,<span class="hljs-built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt;ans;<span class="hljs-comment">//P.first为s至这个点的距离,P.second为从s到的这个点</span>
    ans.push({<span class="hljs-number">0</span>,s});
    <span class="hljs-keyword">while</span>(!ans.empty()){
        P t=ans.top();<span class="hljs-comment">//取最短距离</span>
        ans.pop();<span class="hljs-comment">//弹出最短距离</span>
        <span class="hljs-keyword">if</span>(dp[t.second]&lt;t.first)
            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果弹出的距离不是最新的最短距离，则跳过</span>
        <span class="hljs-keyword">else</span>{
            <span class="hljs-comment">//遍历这个点所连的所有边看是否可以更新到所连边的距离</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a[t.second].<span class="hljs-built_in">size</span>();i++){
                <span class="hljs-keyword">if</span>(dp[a[t.second][i].to]&gt;t.first+a[t.second][i].val){
                    dp[a[t.second][i].to]=t.first+a[t.second][i].val;
                    ans.push({dp[a[t.second][i].to],a[t.second][i].to});
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="413-spfa%E5%8D%95%E6%BA%90--%E8%B4%9F%E6%9D%83%E5%9B%BE">4.1.3. SPFA（单源）--负权图</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>{</span>
    <span class="hljs-keyword">int</span> to,val; <span class="hljs-comment">//to为这条边的终点，val为这条边的权</span>
};
<span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,m,s;<span class="hljs-comment">//n个点，m条边，s起始点</span>
    <span class="hljs-keyword">int</span> inf=INT_MAX;<span class="hljs-comment">//未开long long 使用INT_MAX 可能INT_MAX+INT_MAX溢出导致错误</span>
    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    <span class="hljs-built_in">vector</span>&lt;edge&gt;a[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//存图</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++){
        <span class="hljs-keyword">int</span> u,v,w;<span class="hljs-comment">//u-&gt;v 边权为w</span>
        <span class="hljs-built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        a[u].push_back({v,w});
        a[v].push_back({u,w});<span class="hljs-comment">//无向图</span>
    }
    <span class="hljs-keyword">int</span> dp[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//s至每个点的距离</span>
    <span class="hljs-built_in">fill</span>(dp,dp+n+<span class="hljs-number">1</span>,inf);<span class="hljs-comment">//初始s与所有点不连通   </span>
    dp[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//s至s距离为0</span>
    <span class="hljs-keyword">int</span> vist[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//记录每个点的访问次数</span>
    <span class="hljs-built_in">fill</span>(vist,vist+n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//初始化为0</span>
    <span class="hljs-keyword">int</span> flag[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//判断该点是否在队列里</span>
    <span class="hljs-built_in">fill</span>(flag,flag+n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//初始化为0</span>
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;ans;
    ans.push(s);
    flag[s]=<span class="hljs-number">1</span>;
    vist[s]++;
    <span class="hljs-keyword">bool</span> is=<span class="hljs-number">0</span>;<span class="hljs-comment">//判断是否为负权图</span>
    <span class="hljs-keyword">while</span>(!ans.empty()){
        <span class="hljs-keyword">int</span> t=ans.front();
        ans.pop();
        flag[t]=<span class="hljs-number">0</span>;<span class="hljs-comment">//点取出后不在队列里，标记清除</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a[t].<span class="hljs-built_in">size</span>();i++){
            <span class="hljs-keyword">if</span>(dp[a[t][i].to]&gt;dp[t]+a[t][i].val){
                dp[a[t][i].to]=dp[t]+a[t][i].val;
                <span class="hljs-keyword">if</span>(flag[a[t][i].to]==<span class="hljs-number">0</span>){
                    ans.push(a[t][i].to);
                    flag[a[t][i].to]=<span class="hljs-number">1</span>;
                    vist[a[t][i].to]++;
                }
            }
            <span class="hljs-comment">//如果一个点被访问的次数超过总点数，说明出现了负权边，应该退出</span>
            <span class="hljs-keyword">if</span>(vist[a[t][i].to]&gt;n){
                is=<span class="hljs-number">1</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span>(is)
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="5-%E6%95%B0%E8%AE%BA">5. 数论</h2>
<h3 id="51-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0">5.1. 最大公约数</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">return</span> a==<span class="hljs-number">0</span>?b:gcd(b%a,a);
}
</div></code></pre>
<h3 id="52-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0">5.2. 最小公倍数</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">return</span> a/gcd(a,b)*b;
}
</div></code></pre>
<h3 id="53-%E5%BF%AB%E9%80%9F%E5%B9%82">5.3. 快速幂</h3>
<h4 id="531-%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">5.3.1. 第一种实现方法</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//p为负,返回值为按|p|计算结果</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> p)</span></span>{
    <span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> he=ksm(n,p/<span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span>(p%<span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> he*he*n;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> he*he;
}
</div></code></pre>
<h4 id="532-%E7%AC%AC%E4%BA%8C%E9%92%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">5.3.2. 第二钟实现方法</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//p不能为负</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> p)</span></span>{
    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> f=n;
    <span class="hljs-keyword">while</span>(p){
        <span class="hljs-keyword">if</span>(p&amp;<span class="hljs-number">1</span>)
            ans*=f;
        f*=f;
        p&gt;&gt;=<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="54-%E9%80%86%E5%85%83">5.4. 逆元</h3>
<h4 id="541-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">5.4.1. 费马小定理</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ksm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> mod)</span></span>{
    <span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> he=ksm(n,p/<span class="hljs-number">2</span>,mod);
    <span class="hljs-keyword">if</span>(p%<span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> he*he%mod*n%mod;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> he*he%mod;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> mod)</span></span>{
    <span class="hljs-keyword">return</span> ksm(n,mod<span class="hljs-number">-2</span>,mod);
}
</div></code></pre>
<h3 id="55-%E7%B4%A0%E6%95%B0%E7%AD%9B">5.5. 素数筛</h3>
<h2 id="6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">6. 动态规划</h2>
<h3 id="61-01%E8%83%8C%E5%8C%85">6.1. 01背包</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n为物品数量，m为给定体积</span>
    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;
    <span class="hljs-keyword">int</span> v[n],w[n];<span class="hljs-comment">//v为物品体积，w为物品价值</span>
    <span class="hljs-keyword">int</span> dp[m+<span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        <span class="hljs-built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m;j&gt;=v[i];j--)
            dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h3 id="62-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">6.2. 完全背包</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n为物品数量，m为给定体积</span>
    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;
    <span class="hljs-keyword">int</span> v[n],w[n];<span class="hljs-comment">//v为物品体积，w为物品价值</span>
    <span class="hljs-keyword">int</span> dp[m+<span class="hljs-number">1</span>];
    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        <span class="hljs-built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=v[i];j&lt;=m;j++){
            dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);
        }
    <span class="hljs-built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h2 id="7-%E5%AD%97%E7%AC%A6%E4%B8%B2">7. 字符串</h2>
<h2 id="8-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95">8. 计算几何</h2>

</body>
</html>
